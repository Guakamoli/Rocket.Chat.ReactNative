diff --git a/node_modules/next/dist/client/image.js b/node_modules/next/dist/client/image.js
index e59ba0e..23092a6 100644
--- a/node_modules/next/dist/client/image.js
+++ b/node_modules/next/dist/client/image.js
@@ -33,7 +33,7 @@ const quotient=heightInt/widthInt;const paddingTop=isNaN(quotient)?'100%':`${quo
 wrapperStyle={display:'block',overflow:'hidden',position:'relative',boxSizing:'border-box',margin:0};sizerStyle={display:'block',boxSizing:'border-box',paddingTop};}else if(layout==='intrinsic'){// <Image src="i.png" width="100" height="100" layout="intrinsic" />
 wrapperStyle={display:'inline-block',maxWidth:'100%',overflow:'hidden',position:'relative',boxSizing:'border-box',margin:0};sizerStyle={boxSizing:'border-box',display:'block',maxWidth:'100%'};sizerSvg=`<svg width="${widthInt}" height="${heightInt}" xmlns="http://www.w3.org/2000/svg" version="1.1"/>`;}else if(layout==='fixed'){// <Image src="i.png" width="100" height="100" layout="fixed" />
 wrapperStyle={overflow:'hidden',boxSizing:'border-box',display:'inline-block',position:'relative',width:widthInt,height:heightInt};}}else if(typeof widthInt==='undefined'&&typeof heightInt==='undefined'&&layout==='fill'){// <Image src="i.png" layout="fill" />
-wrapperStyle={display:'block',overflow:'hidden',position:'absolute',top:0,left:0,bottom:0,right:0,boxSizing:'border-box',margin:0};}else{// <Image src="i.png" />
+wrapperStyle={display:'flex', justifyContent:"center", alignItems:"center", overflow:'hidden',position:'absolute',top:0,left:0,bottom:0,right:0,boxSizing:'border-box',margin:0};}else{// <Image src="i.png" />
 if(process.env.NODE_ENV!=='production'){throw new Error(`Image with src "${src}" must use "width" and "height" properties or "layout='fill'" property.`);}}let imgAttributes={src:'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',srcSet:undefined,sizes:undefined};if(isVisible){imgAttributes=generateImgAttrs({src,unoptimized,layout,width:widthInt,quality:qualityInt,sizes,loader});}return/*#__PURE__*/_react.default.createElement("div",{style:wrapperStyle},sizerStyle?/*#__PURE__*/_react.default.createElement("div",{style:sizerStyle},sizerSvg?/*#__PURE__*/_react.default.createElement("img",{style:{maxWidth:'100%',display:'block',margin:0,border:'none',padding:0},alt:"","aria-hidden":true,role:"presentation",src:`data:image/svg+xml;base64,${(0,_toBase.toBase64)(sizerSvg)}`}):null):null,!isVisible&&/*#__PURE__*/_react.default.createElement("noscript",null,/*#__PURE__*/_react.default.createElement("img",Object.assign({},rest,generateImgAttrs({src,unoptimized,layout,width:widthInt,quality:qualityInt,sizes,loader}),{decoding:"async",style:imgStyle,className:className}))),/*#__PURE__*/_react.default.createElement("img",Object.assign({},rest,imgAttributes,{decoding:"async",className:className,ref:element=>{setRef(element);removePlaceholder(element,placeholder);},style:imgStyle})),priority?/*#__PURE__*/ // Note how we omit the `href` attribute, as it would only be relevant
 // for browsers that do not support `imagesrcset`, and in those cases
 // it would likely cause the incorrect image to be preloaded.
diff --git a/node_modules/next/dist/client/link.js b/node_modules/next/dist/client/link.js
index c40443c..099abd9 100644
--- a/node_modules/next/dist/client/link.js
+++ b/node_modules/next/dist/client/link.js
@@ -1,26 +1,27 @@
-"use strict";var _interopRequireWildcard=require("@babel/runtime/helpers/interopRequireWildcard");exports.__esModule=true;exports.default=void 0;var _react=_interopRequireWildcard(require("react"));var _router=require("../next-server/lib/router/router");var _router2=require("./router");var _useIntersection=require("./use-intersection");const prefetched={};function prefetch(router,href,as,options){if(typeof window==='undefined'||!router)return;if(!(0,_router.isLocalURL)(href))return;// Prefetch the JSON page if asked (only in the client)
-// We need to handle a prefetch error here since we may be
-// loading with priority which can reject but we don't
-// want to force navigation since this is only a prefetch
-router.prefetch(href,as,options).catch(err=>{if(process.env.NODE_ENV!=='production'){// rethrow to show invalid URL errors
-throw err;}});const curLocale=options&&typeof options.locale!=='undefined'?options.locale:router&&router.locale;// Join on an invalid URI character
-prefetched[href+'%'+as+(curLocale?'%'+curLocale:'')]=true;}function isModifiedEvent(event){const{target}=event.currentTarget;return target&&target!=='_self'||event.metaKey||event.ctrlKey||event.shiftKey||event.altKey||// triggers resource download
-event.nativeEvent&&event.nativeEvent.which===2;}function linkClicked(e,router,href,as,replace,shallow,scroll,locale){const{nodeName}=e.currentTarget;if(nodeName==='A'&&(isModifiedEvent(e)||!(0,_router.isLocalURL)(href))){// ignore click for browserâ€™s default behavior
-return;}e.preventDefault();//  avoid scroll for urls with anchor refs
-if(scroll==null&&as.indexOf('#')>=0){scroll=false;}// replace state instead of push if prop is present
-router[replace?'replace':'push'](href,as,{shallow,locale,scroll});}function Link(props){if(process.env.NODE_ENV!=='production'){function createPropError(args){return new Error(`Failed prop type: The prop \`${args.key}\` expects a ${args.expected} in \`<Link>\`, but got \`${args.actual}\` instead.`+(typeof window!=='undefined'?"\nOpen your browser's console to view the Component stack trace.":''));}// TypeScript trick for type-guarding:
-const requiredPropsGuard={href:true};const requiredProps=Object.keys(requiredPropsGuard);requiredProps.forEach(key=>{if(key==='href'){if(props[key]==null||typeof props[key]!=='string'&&typeof props[key]!=='object'){throw createPropError({key,expected:'`string` or `object`',actual:props[key]===null?'null':typeof props[key]});}}else{// TypeScript trick for type-guarding:
-// eslint-disable-next-line @typescript-eslint/no-unused-vars
-const _=key;}});// TypeScript trick for type-guarding:
-const optionalPropsGuard={as:true,replace:true,scroll:true,shallow:true,passHref:true,prefetch:true,locale:true};const optionalProps=Object.keys(optionalPropsGuard);optionalProps.forEach(key=>{const valType=typeof props[key];if(key==='as'){if(props[key]&&valType!=='string'&&valType!=='object'){throw createPropError({key,expected:'`string` or `object`',actual:valType});}}else if(key==='locale'){if(props[key]&&valType!=='string'){throw createPropError({key,expected:'`string`',actual:valType});}}else if(key==='replace'||key==='scroll'||key==='shallow'||key==='passHref'||key==='prefetch'){if(props[key]!=null&&valType!=='boolean'){throw createPropError({key,expected:'`boolean`',actual:valType});}}else{// TypeScript trick for type-guarding:
-// eslint-disable-next-line @typescript-eslint/no-unused-vars
-const _=key;}});// This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
-// eslint-disable-next-line react-hooks/rules-of-hooks
-const hasWarned=_react.default.useRef(false);if(props.prefetch&&!hasWarned.current){hasWarned.current=true;console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated');}}const p=props.prefetch!==false;const router=(0,_router2.useRouter)();const{href,as}=_react.default.useMemo(()=>{const[resolvedHref,resolvedAs]=(0,_router.resolveHref)(router,props.href,true);return{href:resolvedHref,as:props.as?(0,_router.resolveHref)(router,props.as):resolvedAs||resolvedHref};},[router,props.href,props.as]);let{children,replace,shallow,scroll,locale}=props;// Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag
-if(typeof children==='string'){children=/*#__PURE__*/_react.default.createElement("a",null,children);}// This will return the first child, if multiple are provided it will throw an error
-let child;if(process.env.NODE_ENV==='development'){try{child=_react.Children.only(children);}catch(err){throw new Error(`Multiple children were passed to <Link> with \`href\` of \`${props.href}\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children`+(typeof window!=='undefined'?"\nOpen your browser's console to view the Component stack trace.":''));}}else{child=_react.Children.only(children);}const childRef=child&&typeof child==='object'&&child.ref;const[setIntersectionRef,isVisible]=(0,_useIntersection.useIntersection)({rootMargin:'200px'});const setRef=_react.default.useCallback(el=>{setIntersectionRef(el);if(childRef){if(typeof childRef==='function')childRef(el);else if(typeof childRef==='object'){childRef.current=el;}}},[childRef,setIntersectionRef]);(0,_react.useEffect)(()=>{const shouldPrefetch=isVisible&&p&&(0,_router.isLocalURL)(href);const curLocale=typeof locale!=='undefined'?locale:router&&router.locale;const isPrefetched=prefetched[href+'%'+as+(curLocale?'%'+curLocale:'')];if(shouldPrefetch&&!isPrefetched){prefetch(router,href,as,{locale:curLocale});}},[as,href,isVisible,locale,p,router]);const childProps={ref:setRef,onClick:e=>{if(child.props&&typeof child.props.onClick==='function'){child.props.onClick(e);}if(!e.defaultPrevented){linkClicked(e,router,href,as,replace,shallow,scroll,locale);}}};childProps.onMouseEnter=e=>{if(!(0,_router.isLocalURL)(href))return;if(child.props&&typeof child.props.onMouseEnter==='function'){child.props.onMouseEnter(e);}prefetch(router,href,as,{priority:true});};// If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
-// defined, we specify the current 'href', so that repetition is not needed by the user
-if(props.passHref||child.type==='a'&&!('href'in child.props)){const curLocale=typeof locale!=='undefined'?locale:router&&router.locale;// we only render domain locales if we are currently on a domain locale
-// so that locale links are still visitable in development/preview envs
-const localeDomain=router&&router.isLocaleDomain&&(0,_router.getDomainLocale)(as,curLocale,router&&router.locales,router&&router.domainLocales);childProps.href=localeDomain||(0,_router.addBasePath)((0,_router.addLocale)(as,curLocale,router&&router.defaultLocale));}return/*#__PURE__*/_react.default.cloneElement(child,childProps);}var _default=Link;exports.default=_default;
-//# sourceMappingURL=link.js.map
\ No newline at end of file
+"use strict";var _interopRequireWildcard=require("@babel/runtime/helpers/interopRequireWildcard");exports.__esModule=true;exports.default=exports.listenToIntersections=void 0;var _react=_interopRequireWildcard(require("react"));var _router=require("../next-server/lib/router/router");var _router2=require("./router");let cachedObserver;const listeners=new Map();const IntersectionObserver=typeof window!=='undefined'?window.IntersectionObserver:null;const prefetched={};function getObserver(){// Return shared instance of IntersectionObserver if already created
+    if(cachedObserver){return cachedObserver;}// Only create shared IntersectionObserver if supported in browser
+    if(!IntersectionObserver){return undefined;}return cachedObserver=new IntersectionObserver(entries=>{entries.forEach(entry=>{if(!listeners.has(entry.target)){return;}const cb=listeners.get(entry.target);if(entry.isIntersecting||entry.intersectionRatio>0){cachedObserver.unobserve(entry.target);listeners.delete(entry.target);cb();}});},{rootMargin:'200px'});}const listenToIntersections=(el,cb)=>{const observer=getObserver();if(!observer){return()=>{};}observer.observe(el);listeners.set(el,cb);return()=>{try{observer.unobserve(el);}catch(err){console.error(err);}listeners.delete(el);};};exports.listenToIntersections=listenToIntersections;function prefetch(router,href,as,options){if(typeof window==='undefined')return;if(!(0,_router.isLocalURL)(href))return;// Prefetch the JSON page if asked (only in the client)
+    // We need to handle a prefetch error here since we may be
+    // loading with priority which can reject but we don't
+    // want to force navigation since this is only a prefetch
+    router.prefetch(href,as,options).catch(err=>{if(process.env.NODE_ENV!=='production'){// rethrow to show invalid URL errors
+    throw err;}});// Join on an invalid URI character
+    prefetched[href+'%'+as]=true;}function isModifiedEvent(event){const{target}=event.currentTarget;return target&&target!=='_self'||event.metaKey||event.ctrlKey||event.shiftKey||event.altKey||// triggers resource download
+    event.nativeEvent&&event.nativeEvent.which===2;}function linkClicked(e,router,href,as,replace,shallow,scroll){const{nodeName}=e.currentTarget;if(nodeName==='A'&&(isModifiedEvent(e)||!(0,_router.isLocalURL)(href))){// ignore click for browserâ€™s default behavior
+    return;}e.preventDefault();//  avoid scroll for urls with anchor refs
+    if(scroll==null){scroll=as.indexOf('#')<0;}// replace state instead of push if prop is present
+    router[replace?'replace':'push'](href,as,{shallow}).then(success=>{if(!success)return;if(scroll){window.scrollTo(0,0);document.body.focus();}});}function Link(props){if(process.env.NODE_ENV!=='production'){function createPropError(args){return new Error(`Failed prop type: The prop \`${args.key}\` expects a ${args.expected} in \`<Link>\`, but got \`${args.actual}\` instead.`+(typeof window!=='undefined'?"\nOpen your browser's console to view the Component stack trace.":''));}// TypeScript trick for type-guarding:
+    const requiredPropsGuard={href:true};const requiredProps=Object.keys(requiredPropsGuard);requiredProps.forEach(key=>{if(key==='href'){if(props[key]==null||typeof props[key]!=='string'&&typeof props[key]!=='object'){throw createPropError({key,expected:'`string` or `object`',actual:props[key]===null?'null':typeof props[key]});}}else{// TypeScript trick for type-guarding:
+    // eslint-disable-next-line @typescript-eslint/no-unused-vars
+    const _=key;}});// TypeScript trick for type-guarding:
+    const optionalPropsGuard={as:true,replace:true,scroll:true,shallow:true,passHref:true,prefetch:true};const optionalProps=Object.keys(optionalPropsGuard);optionalProps.forEach(key=>{if(key==='as'){if(props[key]&&typeof props[key]!=='string'&&typeof props[key]!=='object'){throw createPropError({key,expected:'`string` or `object`',actual:typeof props[key]});}}else if(key==='replace'||key==='scroll'||key==='shallow'||key==='passHref'||key==='prefetch'){if(props[key]!=null&&typeof props[key]!=='boolean'){throw createPropError({key,expected:'`boolean`',actual:typeof props[key]});}}else{// TypeScript trick for type-guarding:
+    // eslint-disable-next-line @typescript-eslint/no-unused-vars
+    const _=key;}});// This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
+    // eslint-disable-next-line react-hooks/rules-of-hooks
+    const hasWarned=_react.default.useRef(false);if(props.prefetch&&!hasWarned.current){hasWarned.current=true;console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://err.sh/vercel/next.js/prefetch-true-deprecated');}}const p=props.prefetch!==false;const[childElm,setChildElm]=_react.default.useState();const router=(0,_router2.useRouter)();const pathname=router&&router.pathname||'/';const{href,as}=_react.default.useMemo(()=>{const[resolvedHref,resolvedAs]=(0,_router.resolveHref)(router,props.href,true);return{href:resolvedHref,as:props.as?(0,_router.resolveHref)(router,props.as):resolvedAs||resolvedHref};},[router,props.href,props.as]);_react.default.useEffect(()=>{if(p&&IntersectionObserver&&childElm&&childElm.tagName&&(0,_router.isLocalURL)(href)){// Join on an invalid URI character
+    const isPrefetched=prefetched[href+'%'+as];if(!isPrefetched){return listenToIntersections(childElm,()=>{prefetch(router,href,as);});}}},[p,childElm,href,as,router]);let{children,replace,shallow,scroll}=props;// Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag
+    if(typeof children==='string'){children=/*#__PURE__*/_react.default.createElement("a",null,children);}// This will return the first child, if multiple are provided it will throw an error
+    const child=_react.Children.only(children);const childProps={ref:el=>{if(el)setChildElm(el);if(child&&typeof child==='object'&&child.ref){if(typeof child.ref==='function')child.ref(el);else if(typeof child.ref==='object'){child.ref.current=el;}}},onClick:e=>{if(child.props&&typeof child.props.onClick==='function'){child.props.onClick(e);}if(!e.defaultPrevented){linkClicked(e,router,href,as,replace,shallow,scroll);}}};if(p){childProps.onMouseEnter=e=>{if(!(0,_router.isLocalURL)(href))return;if(child.props&&typeof child.props.onMouseEnter==='function'){child.props.onMouseEnter(e);}prefetch(router,href,as,{priority:true});};}// If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
+    // defined, we specify the current 'href', so that repetition is not needed by the user
+    if(props.passHref||child.type==='a'&&!('href'in child.props)){childProps.href=(0,_router.addBasePath)(as);}return/*#__PURE__*/_react.default.cloneElement(child,childProps);}var _default=Link;exports.default=_default;
+    //# sourceMappingURL=link.js.map
\ No newline at end of file
